---
description: 現在の差分を確認し、コード全体を見てリファクタリングを行う
argument-hint: [リファクタリングの方針や対象（省略可）]
---

# リファクタリングコマンド

## ステップ0: ブランチ作成

**最初に必ず作業用ブランチを作成してください。**

```bash
git checkout -b refactor/<作業内容を表す名前>
```

- mainブランチで直接作業しない
- ブランチ名は作業内容がわかる名前にする（例: `refactor/extract-utils`, `refactor/simplify-auth`）

---

## 前提条件の確認

以下のサブエージェントの存在を確認してください：

1. **調査系サブエージェント** - `investigator`など、コード調査を行うエージェント
2. **実装系サブエージェント** - `implementer`など、コードを実装するエージェント
3. **コードレビューサブエージェント** - `code-reviewer`など、コード品質をチェックするエージェント

**確認方法**: 利用可能なサブエージェント一覧を確認し、上記に該当するものがあるか判定してください。

**存在しないサブエージェントがある場合**:
ユーザーに以下の形式で報告してください：

```
## 不足しているサブエージェント

以下のサブエージェントが見つかりませんでした：
- [不足しているエージェント名]: [役割の説明]

これらのサブエージェントを作成するか、既存の代替エージェントを指定してください。
```

報告後、ユーザーの指示を待ってください。

---

## リファクタリング方針（オプション）

$ARGUMENTS

---

## リファクタリングプロセス

すべてのサブエージェントが利用可能な場合、以下のプロセスを実行してください：

### フェーズ1: 現状把握

1. **差分の確認**
   - `git diff main` でmainブランチとの差分を確認
   - `git status` で変更されたファイル一覧を取得
   - 差分がない場合は、ユーザーにリファクタリング対象を確認

2. **変更ファイルの特定**
   - 差分があるファイルをリストアップ
   - 各ファイルの変更概要を把握

### フェーズ2: コード分析

3. **コード全体の調査**
   - 調査系サブエージェントを使用して、変更されたファイルの全体構造を分析
   - 以下の観点でリファクタリング候補を特定：

   **構造的な問題**
   - 重複コード（DRY原則違反）
   - 長すぎる関数/メソッド（単一責任の原則違反）
   - 深いネスト
   - 複雑な条件分岐

   **命名・可読性**
   - 不明瞭な変数名・関数名
   - マジックナンバー
   - コメント不足/過剰

   **設計パターン**
   - 適切なパターンの未使用
   - 不適切な依存関係
   - 抽象化の過不足

   **プロジェクト規約**
   - 既存コードのパターンとの不一致
   - コーディング規約違反

4. **リファクタリング計画の作成**
   - 発見した問題点をリストアップ
   - 優先度を設定（高/中/低）
   - 各リファクタリングの影響範囲を評価

### フェーズ3: リファクタリング実行

5. **優先度の高いものから順に実行**
   - 実装系サブエージェントを使用
   - 1つのリファクタリングごとに小さな変更を行う
   - 機能を変更せず、構造のみを改善する

### フェーズ4: 検証

6. **コードレビュー**
   - コードレビューサブエージェントを使用
   - 以下の観点でチェック：
     - リファクタリングが正しく適用されたか
     - 新たな問題が発生していないか
     - コード品質が向上したか
     - 既存の機能が壊れていないか

### フェーズ5: 反復改善

7. **問題の有無を判定**
   - コードレビュー（フェーズ4）の結果を確認

   **問題がある場合**:
   - 問題点をリストアップ
   - フェーズ3（実行）に戻り、問題を修正
   - フェーズ4を再実行
   - これを問題がなくなるまで繰り返す

   **問題がない場合**:
   - 完了報告に進む

### フェーズ6: 完了報告

8. **結果報告**
   以下の形式で報告：

   ```
   ## リファクタリング完了

   ### 対象ファイル
   - [ファイルパス]

   ### 実施したリファクタリング

   #### 1. [リファクタリング名]
   - **問題**: [元の問題点]
   - **改善**: [どう改善したか]
   - **該当箇所**: [ファイル:行番号]

   #### 2. [リファクタリング名]
   ...

   ### 改善指標
   - 重複コード削減: [削減行数またはパーセント]
   - 関数の平均行数: [Before] → [After]
   - 複雑度: [改善があれば記載]

   ### 反復回数
   - 合計: [N]回

   ### 最終レビュー結果
   - [レビュー結果サマリ]

   ### 注意事項
   - [動作確認が必要な箇所など]
   ```

### フェーズ7: Slack通知

9. **Slack通知サブエージェントで結果を共有**
   - `slack-notifier`サブエージェントを使用
   - 以下の内容を送信：

   **メッセージ内容**:
   ```
   🔧 リファクタリング完了

   【対象ファイル】
   [ファイル一覧]

   【実施内容】
   [リファクタリング内容のサマリ]

   【改善指標】
   重複コード削減: [削減行数またはパーセント]
   関数の平均行数: [Before] → [After]

   【反復回数】
   [N]回

   【最終レビュー結果】
   [結果サマリ]
   ```

   **成果物の添付**:
   - `git diff main`の結果（変更が大きい場合はサマリのみ）をメッセージで送信
   - 改善前後の比較が視覚的にわかる場合は、該当部分のコードスニペットを含める

   **注意**: 環境変数`SLACK_TOKEN`と`SLACK_CHANNEL_ID`が未設定の場合は、このフェーズをスキップしてユーザーに通知

---

## リファクタリング種別と適用基準

### 即座に適用すべき（優先度: 高）

| 種別 | 適用基準 |
|------|----------|
| 重複コードの抽出 | 3回以上同じコードが出現 |
| マジックナンバーの定数化 | 意味のある数値がハードコード |
| 長い関数の分割 | 30行を超える関数 |
| 深いネストの解消 | 4段以上のネスト |

### 検討して適用（優先度: 中）

| 種別 | 適用基準 |
|------|----------|
| 変数名・関数名の改善 | 意味が不明瞭 |
| 条件分岐の簡略化 | 複雑な条件式 |
| Early Returnの適用 | else地獄の解消 |
| Guard Clauseの導入 | 事前条件チェックの整理 |

### 慎重に適用（優先度: 低）

| 種別 | 適用基準 |
|------|----------|
| クラス/モジュールの分割 | 責務が複数ある |
| デザインパターンの適用 | 明確なメリットがある場合のみ |
| 抽象化の導入 | 3つ以上の具体実装がある |

---

## 注意事項

- **機能を変更しない**: リファクタリングはコードの外部動作を変えずに内部構造を改善する
- **小さな単位で**: 1回のリファクタリングは1つの改善に集中
- **テストを意識**: テストがある場合は、リファクタリング後もテストが通ることを確認
- **差分がない場合**: ユーザーにリファクタリング対象のファイルや範囲を確認
- 反復は最大5回までとし、それを超える場合はユーザーに相談してください
- 大きな設計変更が必要な場合は、ユーザーに確認を取ってください
